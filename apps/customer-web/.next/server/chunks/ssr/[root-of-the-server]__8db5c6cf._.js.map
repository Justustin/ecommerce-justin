{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///C:/ecommerce/ecommerceMVP/apps/customer-web/app/providers.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\r\nimport { useState } from 'react';\r\n\r\n// ============================================================================\r\n// REACT QUERY CONFIGURATION\r\n// ============================================================================\r\n\r\n/**\r\n * Create a Query Client with default options\r\n * This function is called once per user session\r\n */\r\nfunction makeQueryClient() {\r\n  return new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        // ============================================================================\r\n        // QUERY DEFAULTS\r\n        // ============================================================================\r\n        \r\n        /**\r\n         * Stale time: How long data is considered fresh (5 minutes)\r\n         * Fresh data won't refetch automatically\r\n         */\r\n        staleTime: 5 * 60 * 1000, // 5 minutes\r\n        \r\n        /**\r\n         * Cache time: How long unused data stays in cache (10 minutes)\r\n         * After this, data is garbage collected\r\n         */\r\n        gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)\r\n        \r\n        /**\r\n         * Retry failed requests 2 times before giving up\r\n         * With exponential backoff: 1s, 2s, 4s\r\n         */\r\n        retry: 2,\r\n        \r\n        /**\r\n         * Retry delay with exponential backoff\r\n         */\r\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\r\n        \r\n        /**\r\n         * Refetch on window focus (good for real-time updates)\r\n         * Useful when user comes back to tab\r\n         */\r\n        refetchOnWindowFocus: true,\r\n        \r\n        /**\r\n         * Don't refetch on mount if data is fresh\r\n         * Reduces unnecessary API calls\r\n         */\r\n        refetchOnMount: false,\r\n        \r\n        /**\r\n         * Refetch on network reconnect\r\n         * Ensures data is fresh after coming back online\r\n         */\r\n        refetchOnReconnect: true,\r\n      },\r\n      \r\n      mutations: {\r\n        // ============================================================================\r\n        // MUTATION DEFAULTS\r\n        // ============================================================================\r\n        \r\n        /**\r\n         * Retry mutations once on failure\r\n         * Be conservative with mutations (POST/PUT/DELETE)\r\n         */\r\n        retry: 1,\r\n        \r\n        /**\r\n         * Retry delay for mutations\r\n         */\r\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 10000),\r\n      },\r\n    },\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// BROWSER vs SERVER SETUP\r\n// ============================================================================\r\n\r\n/**\r\n * Browser: Create query client once and reuse\r\n * Server: Create new client per request (Next.js SSR)\r\n */\r\nlet browserQueryClient: QueryClient | undefined = undefined;\r\n\r\nfunction getQueryClient() {\r\n  if (typeof window === 'undefined') {\r\n    // Server: always create new client\r\n    return makeQueryClient();\r\n  } else {\r\n    // Browser: reuse existing client\r\n    if (!browserQueryClient) {\r\n      browserQueryClient = makeQueryClient();\r\n    }\r\n    return browserQueryClient;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// PROVIDERS COMPONENT\r\n// ============================================================================\r\n\r\n/**\r\n * Providers component to wrap the entire app\r\n * Sets up React Query for data fetching\r\n * \r\n * Usage in app/layout.tsx:\r\n * <Providers>\r\n *   {children}\r\n * </Providers>\r\n */\r\nexport default function Providers({ children }: { children: React.ReactNode }) {\r\n  /**\r\n   * Use useState to ensure client is created only once per component mount\r\n   * This prevents hydration issues in Next.js 14\r\n   */\r\n  const [queryClient] = useState(() => getQueryClient());\r\n  \r\n  return (\r\n    <QueryClientProvider client={queryClient}>\r\n      {children}\r\n      \r\n      {/* React Query Devtools - Only in development */}\r\n      {process.env.NODE_ENV === 'development' && (\r\n        <ReactQueryDevtools \r\n          initialIsOpen={false}\r\n          position=\"bottom\"\r\n          buttonPosition=\"bottom-right\"\r\n        />\r\n      )}\r\n    </QueryClientProvider>\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// USAGE EXAMPLES\r\n// ============================================================================\r\n\r\n/**\r\n * Example 1: Using in app/layout.tsx\r\n * \r\n * import Providers from './providers';\r\n * \r\n * export default function RootLayout({\r\n *   children,\r\n * }: {\r\n *   children: React.ReactNode;\r\n * }) {\r\n *   return (\r\n *     <html lang=\"id\">\r\n *       <body>\r\n *         <Providers>\r\n *           {children}\r\n *         </Providers>\r\n *       </body>\r\n *     </html>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * Example 2: Using useQuery in a component\r\n * \r\n * import { useQuery } from '@tanstack/react-query';\r\n * import { getProducts } from '@/lib/api/products';\r\n * \r\n * function ProductList() {\r\n *   const { data, isLoading, error } = useQuery({\r\n *     queryKey: ['products'],\r\n *     queryFn: () => getProducts({ limit: 12 })\r\n *   });\r\n *   \r\n *   if (isLoading) return <div>Loading...</div>;\r\n *   if (error) return <div>Error loading products</div>;\r\n *   \r\n *   return (\r\n *     <div>\r\n *       {data?.data.map(product => (\r\n *         <ProductCard key={product.id} product={product} />\r\n *       ))}\r\n *     </div>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * Example 3: Using useMutation for form submission\r\n * \r\n * import { useMutation, useQueryClient } from '@tanstack/react-query';\r\n * import { joinGroupSession } from '@/lib/api/products';\r\n * \r\n * function JoinGroupButton({ sessionId }) {\r\n *   const queryClient = useQueryClient();\r\n *   \r\n *   const { mutate, isPending } = useMutation({\r\n *     mutationFn: (data) => joinGroupSession(sessionId, data),\r\n *     onSuccess: () => {\r\n *       // Invalidate and refetch group session data\r\n *       queryClient.invalidateQueries({ queryKey: ['group-session', sessionId] });\r\n *       toast.success('Berhasil bergabung!');\r\n *     },\r\n *     onError: (error) => {\r\n *       toast.error('Gagal bergabung: ' + error.message);\r\n *     }\r\n *   });\r\n *   \r\n *   return (\r\n *     <button \r\n *       onClick={() => mutate({ quantity: 1 })}\r\n *       disabled={isPending}\r\n *     >\r\n *       {isPending ? 'Loading...' : 'Gabung Grup'}\r\n *     </button>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * Example 4: Prefetching data for faster navigation\r\n * \r\n * import { useQueryClient } from '@tanstack/react-query';\r\n * import { getProductById } from '@/lib/api/products';\r\n * \r\n * function ProductCard({ product }) {\r\n *   const queryClient = useQueryClient();\r\n *   \r\n *   // Prefetch product details on hover\r\n *   const handleMouseEnter = () => {\r\n *     queryClient.prefetchQuery({\r\n *       queryKey: ['product', product.id],\r\n *       queryFn: () => getProductById(product.id)\r\n *     });\r\n *   };\r\n *   \r\n *   return (\r\n *     <div onMouseEnter={handleMouseEnter}>\r\n *       <Link href={`/products/${product.slug}`}>\r\n *         {product.name}\r\n *       </Link>\r\n *     </div>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * Example 5: Optimistic updates for better UX\r\n * \r\n * import { useMutation, useQueryClient } from '@tanstack/react-query';\r\n * import apiClient from '@/lib/api/client';\r\n * \r\n * function LikeButton({ productId }) {\r\n *   const queryClient = useQueryClient();\r\n *   \r\n *   const { mutate } = useMutation({\r\n *     mutationFn: () => apiClient.post(`/products/${productId}/like`),\r\n *     \r\n *     // Optimistically update UI before API call completes\r\n *     onMutate: async () => {\r\n *       // Cancel outgoing refetches\r\n *       await queryClient.cancelQueries({ queryKey: ['product', productId] });\r\n *       \r\n *       // Snapshot current value\r\n *       const previousProduct = queryClient.getQueryData(['product', productId]);\r\n *       \r\n *       // Optimistically update\r\n *       queryClient.setQueryData(['product', productId], (old: any) => ({\r\n *         ...old,\r\n *         likes: (old?.likes || 0) + 1,\r\n *         isLiked: true\r\n *       }));\r\n *       \r\n *       return { previousProduct };\r\n *     },\r\n *     \r\n *     // Rollback on error\r\n *     onError: (err, variables, context) => {\r\n *       queryClient.setQueryData(\r\n *         ['product', productId],\r\n *         context?.previousProduct\r\n *       );\r\n *     },\r\n *     \r\n *     // Refetch after success/error\r\n *     onSettled: () => {\r\n *       queryClient.invalidateQueries({ queryKey: ['product', productId] });\r\n *     }\r\n *   });\r\n *   \r\n *   return <button onClick={() => mutate()}>Like</button>;\r\n * }\r\n */\r\n\r\n/**\r\n * Example 6: Dependent queries (wait for first query before second)\r\n * \r\n * import { useQuery } from '@tanstack/react-query';\r\n * import { getProductById, getActiveGroupSession } from '@/lib/api/products';\r\n * \r\n * function ProductDetail({ productId }) {\r\n *   // First query: Get product\r\n *   const { data: product } = useQuery({\r\n *     queryKey: ['product', productId],\r\n *     queryFn: () => getProductById(productId)\r\n *   });\r\n *   \r\n *   // Second query: Get active session (only runs after product is loaded)\r\n *   const { data: session } = useQuery({\r\n *     queryKey: ['group-session', productId],\r\n *     queryFn: () => getActiveGroupSession(productId),\r\n *     enabled: !!product // Only run if product exists\r\n *   });\r\n *   \r\n *   return <div>...</div>;\r\n * }\r\n */\r\n\r\n/**\r\n * Example 7: Infinite scroll with useInfiniteQuery\r\n * \r\n * import { useInfiniteQuery } from '@tanstack/react-query';\r\n * import { getProducts } from '@/lib/api/products';\r\n * \r\n * function InfiniteProductList() {\r\n *   const {\r\n *     data,\r\n *     fetchNextPage,\r\n *     hasNextPage,\r\n *     isFetchingNextPage\r\n *   } = useInfiniteQuery({\r\n *     queryKey: ['products', 'infinite'],\r\n *     queryFn: ({ pageParam = 1 }) => getProducts({ page: pageParam }),\r\n *     getNextPageParam: (lastPage) => {\r\n *       const { page, total_pages } = lastPage.pagination;\r\n *       return page < total_pages ? page + 1 : undefined;\r\n *     },\r\n *     initialPageParam: 1\r\n *   });\r\n *   \r\n *   return (\r\n *     <div>\r\n *       {data?.pages.map((page) =>\r\n *         page.data.map((product) => (\r\n *           <ProductCard key={product.id} product={product} />\r\n *         ))\r\n *       )}\r\n *       \r\n *       {hasNextPage && (\r\n *         <button onClick={() => fetchNextPage()}>\r\n *           {isFetchingNextPage ? 'Loading...' : 'Load More'}\r\n *         </button>\r\n *       )}\r\n *     </div>\r\n *   );\r\n * }\r\n */"],"names":[],"mappings":";;;;;AAEA;AAAA;AACA;AACA;AAJA;;;;;AAMA,+EAA+E;AAC/E,4BAA4B;AAC5B,+EAA+E;AAE/E;;;CAGC,GACD,SAAS;IACP,OAAO,IAAI,qQAAW,CAAC;QACrB,gBAAgB;YACd,SAAS;gBACP,+EAA+E;gBAC/E,iBAAiB;gBACjB,+EAA+E;gBAE/E;;;SAGC,GACD,WAAW,IAAI,KAAK;gBAEpB;;;SAGC,GACD,QAAQ,KAAK,KAAK;gBAElB;;;SAGC,GACD,OAAO;gBAEP;;SAEC,GACD,YAAY,CAAC,eAAiB,KAAK,GAAG,CAAC,OAAO,KAAK,cAAc;gBAEjE;;;SAGC,GACD,sBAAsB;gBAEtB;;;SAGC,GACD,gBAAgB;gBAEhB;;;SAGC,GACD,oBAAoB;YACtB;YAEA,WAAW;gBACT,+EAA+E;gBAC/E,oBAAoB;gBACpB,+EAA+E;gBAE/E;;;SAGC,GACD,OAAO;gBAEP;;SAEC,GACD,YAAY,CAAC,eAAiB,KAAK,GAAG,CAAC,OAAO,KAAK,cAAc;YACnE;QACF;IACF;AACF;AAEA,+EAA+E;AAC/E,0BAA0B;AAC1B,+EAA+E;AAE/E;;;CAGC,GACD,IAAI,qBAA8C;AAElD,SAAS;IACP,wCAAmC;QACjC,mCAAmC;QACnC,OAAO;IACT;;AAOF;AAee,SAAS,UAAU,EAAE,QAAQ,EAAiC;IAC3E;;;GAGC,GACD,MAAM,CAAC,YAAY,GAAG,IAAA,gVAAQ,EAAC,IAAM;IAErC,qBACE,6WAAC,6SAAmB;QAAC,QAAQ;;YAC1B;YAGA,oDAAyB,+BACxB,6WAAC,8SAAkB;gBACjB,eAAe;gBACf,UAAS;gBACT,gBAAe;;;;;;;;;;;;AAKzB,EAEA,+EAA+E;CAC/E,iBAAiB;CACjB,+EAA+E;CAE/E;;;;;;;;;;;;;;;;;;;;CAoBC,IAED;;;;;;;;;;;;;;;;;;;;;;;CAuBC,IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BC,IAED;;;;;;;;;;;;;;;;;;;;;;;;;CAyBC,IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8CC,IAED;;;;;;;;;;;;;;;;;;;;;;CAsBC,IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCC","debugId":null}}]
}